# 添加web
右键点击Add Framework Support选择

# 依赖添加
给项目配置好tomcat启动之后，可以直接点击Project Structure选择Modules，选择项目，点击dependenciesm，选择右侧的加号，选择该tomcat

# super栈内存
先存入子类main方法和构造方法，再存入父类构造方法，调用父类，出去栈中父类内存，再调用子类，去掉子类内存

# package包，对类进行分类和使用

# 抽象类和接口
抽象类对事物的定义，接口对行为的抽象

# watch包
篮球运动员和乒乓球运动员继承自学习类，篮球教练和乒乓球教练继承自教学类，学习类和教学类继承自吃饭类

# 形参和返回值
1:类名作为形参和返回值
方法的形参是类名，其实需要的是该类的对象
方法的返回值是类名，其实返回的是该类的对象
2:抽象类名作为形参和返回值
抽象类不能实例化，子类重写抽象类方法，然后用多态方法实例化子类在抽象类引用上，作为参数传递

# 接口名作为形参和返回值
接口不能实例化，也是使用多态方式

# 内部类
一个类内部定义一个类
内部类可以直接访问外部类成员，包括私有，外部类要访问内部类的成员，必须创建对象

# 成员内部类
类的成员位置：成员内部类。   类的局部位置：局部内部类。
外部访问内部类，比如manageStudent中的：ManageStudent.InnerStudent oi = new ManageStudent().new InnerStudent();
内部类就是为了不让外部访问，如果使用private，就不能上述方法调用
局部内部类：比如manageStudent中的BuInner，在方法内部创建局部内部类，外部不能访问，需要在方法内部创建对象使用，该类可以访问外部类成员和方法内变量
匿名内部类，是一个继承了该类或者实现了该接口的匿名对象。在开发中使用

# hashSet集合和特点
底层数据结构是哈希表，对集合的迭代顺序不作任何保证，没有带索引的方法，不能使用普通for遍历，由于是Set集合，不包含重复元素
hashset保证元素唯一的源码：hash值和元素的hashCode方法相关,根据hash值计算对象的存储位置，如果该位置没有元素，就存储元素。如果该位置有元素，就和该位置所有已存在元素比较哈希值，
如果hash值都不同，继续向下执行，把元素添加到集合，如果hash值有相同，会调用对象equals方法比较，如果false，会继续向下执行，把元素添加到集合，如果返回true，说明元素重复，不存储
## 哈希表
hashSet默认长度是16，
计算hash值的存储位置，使用hash对16取余得到位置。所以不同数据位置可能相同。
## LinkedHashSet
哈希表和链表实现的set接口，具有可预测的迭代次序。由链表保证元素有序，哈希表保证元素唯一
## TreeSet
元素按照一定规则进行排序，排序方法取决构造方法。无参是自然排序，有参根据指定的比较器排序。没有带索引的方法，不包含重复元素
定义treeset，类型使用一个类，这个类需要实现接口Comparable，重写自然排序方法compareTo
比较器排序：是带参构造方法的比较器排序对元素进行排序的，就是让集合构造方法接收接收Compartor的实现类对象，重写compare方法，

# 泛型
定义时添加<type>,把运行时的错误提前到编码时候，避免的类型转换。泛型把列表等多个数据的每一个数据格式确定了。
泛型类，给类添加泛型，new这个类的时候，在类名后面加<类型>,这个类内部就可以使用任意类型了。
## 类型通配符
<?>: 表示元素类型未知的List，他的元素可以匹配任何的类型。这种list仅表示他是各种泛型list的父类，并不能把元素添加到其中
、<? extend 类型>: 表示某个类型或者其子类型
、<? super 类型>: 表示某个类型或其父类型

# 可变参数
定义方法使用(String b, int... a)，a就是表示所有参数数组，可变参数放最后

# Map
将键映射到值的对象，键不能重复，每个键最多一个值
将类对象作为Map的键，需要重写这个类的equals和hashCode方法

# IO流
## 字节流
如果数据通过window自带记事本打开的就是字符流，打开看不懂的应该使用字节流
inputStream抽象类，是表示字节输入流的所有类的超类
outStream：抽象类，表示字节输出流的所有类的超类
子类名特点：子类名称是以其父类名结尾

设置缓冲输出流，应用可以向底层输出流写入字节，不必为写入的每个字节导致系统调用BufferedOutputStream(OutputStream out)
缓冲流仅仅提供缓冲区，真正读写数据还得依靠基本的字节流对象进行操作

## 字符流
一个汉字：GBK编码，占用两个字节。UTF-8编码，占用3个字节
字符流=字节流+编码表
汉字存储，无论那种编码，第一个字节肯定是负的
## 编码表
计算机中的信息都是二进制数表示的，我们屏幕上看到的英文，汉字等字符是二进制数转换之后的结果
安装某种规则将字符存储到计算机中称为编码，反之解码
### 字符集
ASCII。  GDXXX:（ GB2312,GBK）  Unicode
Unicode为表达任意语言的任意字符设计的（UTF-8）,是业界的一种标准，也称为统一码
采用何种规则编码就要采用何种规则解码
字符流抽象基类：
Reader：字符输入流基类，Writer：字符输出流基类
字符流相对字节流是有缓冲的，可以使用flush刷新
字符流使用OutputStreamWriter和InputStreamReader，可以切换编码(默认utf-8)，如果不改变编码，使用FileWrite和FileReader替换字符流和字节流
字符缓冲流和字节缓冲流类似，也有类BUfferWriter和BufferReader：有特别的功能
newLine()写一行行分隔符
readLine()读一行文字，结果包含行的内容的字符串，不包含任何终止字符,只读内容，不读换行
## 对象序列化流
将对象保存到磁盘中，或者在网络中传输对象
使用一个字节序列表示一个对象，该字节序列包含：对象的类型，对象的数据和对象中存储的属性等信息
字节序列写到文件之后，相当于文件中持久保持了一个对象的信息
反之，该字节序列还可以从文件中读取回来，重构对象，对他进行反序列化
一个类要想被实例化，该类需要实现Serializable接口
### 对象序列化流之后，修改对象类文件，再读取文件，会报错
//    1：类的串行版本与从流中读取的类描述符的类型不匹配
//    2：该类包含未知的数据类型                            
//    3：该类没有可访问的无参数构造函数
添加一行ID：    private static final long serialVersionUID = 42L;
使用transient修饰变量，该变量不参与序列化过程

# 进程线程
单线程：一个进程如果只有一条执行路径，称为单线程程序
多线程：多条路径
java虚拟机可以实现多线程
Runnable接口实现多线程
## 线程调度
分时调度模型和抢占式调度模型
java使用抢占式
假如计算机只有一个CPU，那么CPU在某个时刻只能执行一个指令，线程只有得到CPU时间片，也就是使用权，才能执行指令，多线程执行是随机性的
线程声明周期： 新建，就绪，抢CPU执行权，运行，run，死亡
当线程运行时候没有执行权，就回到抢CPU执行权
运行时候sleep，到阻塞过程，阻塞结束到抢CPU执行权

### 多线程的数据安全问题
是否是多线程，是否数据共享，是否有多条语句操作数据
符合上述三条就会有数据安全问题
解决数据安全：
    把多条语句操作共享数据的代码锁起来，让他们在进程中只会有一个执行
1：同步代码快：synchronized
好处：解决了多线程的数据安全问题
弊端：当线程很多时，因为每个线程都会执行一次锁，造成资源浪费，会降低程序的运行效率
2：同步方法：synchronized加到方法类型后面
3:同步静态方法：加到static后面，锁对象是类名.class
线程安全的类：
StringBuffer，Vector，HashTable
还有Collections.synchronizedList将方法包裹成同步方法
### Lock锁
# 网络编程
339





